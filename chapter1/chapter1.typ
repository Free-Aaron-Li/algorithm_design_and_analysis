#import "../typst/template/reference.typ": POINT,NOTE,TIP,cn_fake-italic,indent,example,line_cs,line_end,line_dc,THEOREM
#import "../typst/template/page/basic.typ":basic
#import "@preview/tablem:0.1.0": tablem

#let center_title = [Algorithm \ Design&Analysis]
#show:doc=>basic(
  title: center_title, // 标题
  authors: ((
    name: "aaron.li",
    affiliation: "pzhu",
    email: "communicate_aaron@outlook.com",
  ),),
  doc,
  chapter: 1,
)

= 第一周

#image("./asset/img/算法课程主要内容及其有关概念.png")

#line_cs

== 两个例子：调度问题与投资问题

=== 调度问题

*问题* 有n项任务，每项任务加工时间已知。从0时刻开始陆续安排到一台机器上加工。每个任务的完成时间是从0时刻到任务加工截止的时间。

*求* 总完成时间（所有任务完成时间之和）；最短的安排方案。

#rect(width: 100%, radius: 0.5em)[
  *实例* \
  任务集 $S={1,2,3,4,5}$，\
  加工时间：$t_1=3,t_2=8,t_3=5,t_4=10,t_5=15$
]

#line_dc

对于该问题，我们可以尝试采用如下解决方案：

*算法*：按加工时间从小到大安排

*解*：安排方案序列为：1,3,2,4,5

总完成时间：
$
  t
    &=3+(3+5)+(3+5+8)+(3+5+8+10)+(3+5+8+10+15) \
    &=3*5+5*4+8*3+10*2+15*1 \
    &=94
$

#line_dc

对问题进行*建模*可得：

*输入：*任务集：$S={1,2,...,n}$，\
#h(5em)第j项任务加工时间：$t_j in Z^+,j=1,2,...,n$。

*输出：*调度I，S的排列 $i_1,i_2,...,i_n$，

*目标函数：* I的完成时间，$t(I)=sum_(k=1)^n (n-k+1)t_(i_k)$

*解$I^*$：* 使得$t(I^*)$达到最小，即\
#h(5em)$t(I^*)=min{t(I)mid(|)"I为S的排列"}$

根据建模，我们设计出对应的*算法*：

#indent*设计策略：* 加工时间短的先做（实际上即是“*贪心算法*”）

*算法：* 根据加工时间从小到大排序，依次加工

*算法正确性：* 对所有输入实例都得到最优解

#line_dc

该算法是否正确呢？我们进行证明：

*证：* 假如调度f第i，j项任务相邻且有逆序，即$t_i>t_j$。交换任务i和j得到调度g。

那么，实际影响就变成：加工时间长的次数减一，加工时间短的次数加一，总完成时间 $t(g)-t(f)=t_j-t_i<0$。

对任务进行由小到大排列，得到的差值为负。说明该算法是有效的，能够得到最优解。

#parbreak()

对任务进行大小排序已获得最优解，这种思路并不总是正确的，例如：

*反例：* 有4件物品要装入背包，物品重量和价值如下：

#align(center)[
  #tablem(ignore-second-row: false)[
    |*标号*|1|2|3|4| |重量$w_i$|3|4|5|2| |价值$v_i$|7|9|9|2|
  ]
]

#indent 背包重量限制是6，问如何选择物品，使得不超重的情况下装入背包的物品价值达到最大？

按照我们之前的思路：

*贪心法：*单位重量价值大的优先，总重不超过6。

按照$frac(v_i, w_i)$从大到小排序：1,2,3,4
$
  7/3>9/4>9/5>2/2
$

#indent 贪心法的解：{1,4}，重量5,价值为9。

更好的解：{3,4}，重量6,价值11。

这说明了贪心算法并不是对所有的问题都具有最优解。
#line_dc

总结以下算法的通用设计：

+ 问题建模
+ 选择什么算法？如何描述这个方法？
+ 这个方法是否对所有实例都得到最优解？如何证明？
+ 如果不是，能否找到反例？

=== 投资问题

*问题：* m元钱，投资n个项目。效益函数$f_i(x)$，表示第i个项目投入x元的效益，$i=1,2,...,n$。

*求：*如何分配每个项目的钱数使得总效益最大？

#rect(
  width: 100%,
  radius: 0.5em,
)[
  *实例* \
  5万元，投资给4个项目，效益函数：

  #align(
    center,
  )[
    #tablem(
      ignore-second-row: false,
      align: center,
    )[
      |x|$f_1(x)$|$f_2(x)$|$f_3(x)$|$f_4(x)$| |0|0|0|0|0| |1|11|0|2|20| |2|12|5|10|21|
      |3|13|10|30|22| |4|14|15|32|23| |5|15|20|40|24|
    ]
  ]
]

#line_dc

还是一样的步骤，首先对该问题进行建模：

*输入：* $n,m,f_i(x),i=1,2,...,n,x=1,2,..,m$

*解：* n维向量$<x_1,x_2,...,x_n>$，$x_i$是第i个项目的钱数，使得下述条件满足：

#{
  [
    #set math.cases(gap: 1em)
    $
      cases(
        max sum_(i=1)^n f_i(x_i) &"目标函数",
        sum_(i=1)^n x_i=m "," #h(0.5em)x_i in N &"约束条件",

      )
    $
  ]
}

#indent 对于该问题，我们一般首先想到的是穷举思路（即“*蛮力算法*”）

对所有满足下述条件的向量$<x_1,x_2,...,x_n>$有，
$
  x_1+x_2+...+x_n=m \
  x_i "为非负整数"i=1,2,...,n
$

#indent 计算相应的效益
$
  f_1(x_1)+f_2(x_2)+...+f_n(x_n)
$

#indent 从中确认效益最大的向量。

*实例计算：*

$
  x_1+x_2+x_3+x_4=5 \
  s_1=<0,0,0,5>,v(s_1)=24 \
  s_2=<0,0,1,4>,v(s_2)=25 \
  s_3=<0,0,2,3>,v(s_3)=32 \
  ... \
  s_56=<5,0,0,0>,v(s_56)=15
$

#indent 得出最大效益方案为：$s=<1,0,3,1>$，$v(s)=11+30+20=61$

但是该算法的效率十分低！

*求解算法效率：*

方程$x_1+x_2+...+x_n=m$的非负整数解$<x_1,x_2,...,x_n>$的个数估计：

可行解表示成0-1序列：m个1,n-1个0

$
  underbrace(1...1, x_1"个")0underbrace(1...1, x_2"个")0...0underbrace(1...1, x_n"个")
$

#indent 例如：n=4，m=7

可行解 $<1,2,3,1> <=> "序列" 1 0 1 1 0 1 1 1 0 1$，这样解的个数恰好和序列个数是一致的（解的个数变成了0插入序列中位置的种类数，排列组合即可求解）。

序列个数的输入规模的指数函数：
$
  C(m+n-1,m) \
    &=frac((m+n-1)!, m!(n-1)!) \
    &=Omega((1+epsilon)^m+n-1), #h(1em)epsilon>0
$

#indent 借此可以得出，采用穷举的方式得到最优解的效率是十分低下的。

#line_dc

#align(center)[
  #text(size: 15pt, fill: red)[*小结*]
]

问题求解的关键

- 建模：对输入参数和解给出形式化或半形式化的描述
- 设计算法：
  - 采用什么算法设计技术
  - 正确性——是否对所有的实例都得到正确的解
- 分析算法——效率

#line_cs

